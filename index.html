<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>皇室战争记牌器 · 2025 百度语音识别手动输入版</title>
<style>
    body {font-family:"Microsoft YaHei",Arial,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);margin:0;padding:20px;color:#fff;min-height:100vh;position:relative}
    .container {max-width:1200px;margin:auto;display:grid;grid-template-columns:1fr 400px;gap:25px}
    .main {background:rgba(255,255,255,0.15);backdrop-filter:blur(15px);border-radius:25px;padding:30px;box-shadow:0 10px 40px rgba(0,0,0,0.4)}
    h1 {text-align:center;margin:0 0 20px}
    .config {background:rgba(255,255,255,0.15);border-radius:18px;padding:20px;margin-bottom:25px;text-align:center}
    input {width:90%;padding:14px;border-radius:12px;border:none;font-size:16px;margin:8px 0}
    button {padding:14px 30px;margin:8px;font-size:17px;border:none;border-radius:50px;cursor:pointer;font-weight:bold;transition:all .3s}
    #getToken {background:#007bff}#startBtn {background:#28a745}#stopBtn {background:#dc3545}#undoBtn {background:#6c757d}#resetBtn {background:#ffc107;color:#000}
    button:hover {transform:translateY(-5px);box-shadow:0 10px 25px rgba(0,0,0,0.5)}
    button:disabled {opacity:0.5;cursor:not-allowed}
    .status {text-align:center;padding:20px;background:rgba(0,0,0,0.4);border-radius:18px;font-size:19px;margin:20px 0}
    .slots {display:grid;grid-template-columns:repeat(4,1fr);gap:20px}
    .slot {height:140px;border-radius:20px;display:flex;align-items:center;justify-content:center;font-size:21px;font-weight:bold;box-shadow:0 8px 30px rgba(0,0,0,0.5)}
    .used {background:linear-gradient(135deg,#ff5e5e,#ff304f)}
    .library {background:linear-gradient(135deg,#00d2ff,#0099ff)}
    .speech-text {background:rgba(0,0,0,0.6);border-radius:20px;padding:20px;margin-top:20px;text-align:center;font-size:24px;font-weight:bold;min-height:80px;border:2px solid rgba(255,255,255,0.3);backdrop-filter:blur(10px)}
    .atlas {background:rgba(255,255,255,0.15);backdrop-filter:blur(15px);border-radius:25px;padding:25px;max-height:90vh;overflow-y:auto}
    .search {width:100%;padding:14px;margin-bottom:20px;border-radius:15px;border:none;font-size:16px}
    .card-list {display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    .card-btn {background:rgba(255,255,255,0.25);border:none;border-radius:12px;padding:12px 8px;font-size:14px;cursor:pointer;transition:all .2s}
    .card-btn:hover {background:rgba(255,255,255,0.45);transform:scale(1.08)}
    #toast {position:fixed;bottom:30px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.92);color:#fff;padding:18px 40px;border-radius:50px;font-size:24px;font-weight:bold;box-shadow:0 15px 40px rgba(0,0,0,0.6);backdrop-filter:blur(12px);z-index:9999;opacity:0;transition:all .4s;pointer-events:none;border:2px solid rgba(255,255,255,0.3)}
    #toast.show {opacity:1;transform:translateX(-50%) translateY(-15px)}
</style>
</head>
<body>
<div class="container">
    <div class="main">
        <h1>皇室战争记牌器 2025 百度智能云版</h1>
       
        <div class="config">
            <div style="font-size:18px;margin-bottom:10px">百度语音识别配置</div>
            <input type="text" id="appid" placeholder="AppID">
            <input type="text" id="apiKey" placeholder="API Key">
            <input type="text" id="secretKey" placeholder="Secret Key">
            <div style="margin-top:15px">
                <button id="getToken">保存配置</button>
            </div>
            <div style="margin-top:10px;font-size:15px" id="tokenStatus">填写后点击保存</div>
        </div>
        <div style="text-align:center">
            <button id="startBtn" disabled>开始实时监听</button>
            <button id="stopBtn" disabled>停止监听</button>
            <button id="undoBtn" disabled>撤销上一张</button>
            <button id="resetBtn">清空卡槽</button>
        </div>
        <div class="status" id="status">请先填写配置并保存</div>
        <div class="slots" id="slots"></div>
       
        <!-- 实时语音文字显示栏 -->
        <div class="speech-text" id="speechText">
            听到的内容会实时显示在这里...
        </div>
    </div>
    <div class="atlas">
        <h2 style="text-align:center">卡牌图鉴（点我补录）</h2>
        <input type="text" class="search" placeholder="搜索卡牌…" id="searchInput">
        <div class="card-list" id="cardList"></div>
    </div>
</div>
<div id="toast">识别成功</div>
<script>
// 完整卡牌库与别名
const allCards = ["骑士","弓箭手","哥布林","炸弹兵","骷髅兵","野蛮人","亡灵","烈焰精灵","蝙蝠","迷你皮卡","哥布林团伙","野蛮人精锐","皇家卫队","重甲亡灵","皇家巨人","哥布林投矛手","骷髅飞龙","冰雪精灵","绿林团伙","烟花炮手","火枪手","瓦基丽武神","野猪骑士","三个火枪手","吹箭哥布林","治疗精灵","飞龙宝宝","骷髅军团","女巫","气球兵","黑暗王子","王子","哥布林巨人","猎人","雷电飞龙","骷髅守卫","巨石投手","飞斧屠夫","加农炮战车","掘地矿工","公主","超级骑士","寒冰法师","地狱飞龙","蛮羊骑士","熔岩猎犬","闪电法师","电磁炮","皇家幽灵","神箭游侠","幻影刺客","暗夜女巫","狂暴樵夫","女巫婆婆","渔夫","弓箭女皇","黄金圣骑","骷髅帝王","皇家塔公主","炮兵","飞刀女爵","皇家大厨","万箭齐发","电击法术","大雪球","皇家速递","火球","火箭","地震法术","野蛮人滚桶","哥布林飞桶","雷电法术","冰冻法术","伤害药水法术","镜像法术","狂暴法术","克隆法术","飓风法术","滚木","骷髅召唤","加农炮","迫击炮","特斯拉电磁塔","哥布林牢笼","骷髅墓碑","地狱之塔","哥布林小屋","烈焰熔炉","炸弹塔","圣水收集器","野蛮人小屋","十字连弩","哥布林钻机","法师","巨人","攻城炸弹人","皮卡超人","戈仑石人","战斗天使","皇家野猪","电击车小队","圣水戈仑","骷髅气球","骷髅巨人","飞行器"];
const aliasMap = {"皮卡":"皮卡超人","逼卡":"皮卡超人","pika":"皮卡超人","皮卡丘":"皮卡超人","矿":"掘地矿工","矿工":"掘地矿工","墓园":"骷髅墓碑","墓地":"骷髅墓碑","坟":"骷髅墓碑","石头":"戈仑石人","戈仑":"戈仑石人","狗球":"戈仑石人","石":"戈仑石人","宝宝":"飞龙宝宝","小龙":"飞龙宝宝","飞龙":"飞龙宝宝","大电":"雷电法术","闪电":"雷电法术","电击":"雷电法术","箭雨":"万箭齐发","小箭雨":"万箭齐发","三枪":"三个火枪手","火枪":"三个火枪手","火枪手":"三个火枪手","超骑":"超级骑士","骑士超":"超级骑士","樵夫":"狂暴樵夫","狂暴樵夫":"狂暴樵夫","气球":"气球兵","球":"气球兵","冰法":"寒冰法师","火法":"闪电法师"};
let slots = [], lastAddTime = 0;
const toast = document.getElementById('toast');
const speechText = document.getElementById('speechText');

// 语音识别相关变量
let ws = null;
let audioContext = null;
let source = null;
let processor = null;
let isRecording = false;
const SAMPLE_RATE = 16000;
const cuid = 'clash-royale-' + Math.random().toString(36).substr(2, 9);
let sn = null;
let reconnectAttempts = 0;
const MAX_RECONNECTS = 2;
let transcriptBuffer = ''; // 新增：文本缓冲区，用于积累实时文本并检索关键词
const MAX_BUFFER_LENGTH = 500; // 缓冲区上限，防止无限积累

// UI函数
function showToast(t){toast.textContent=t;toast.classList.add('show');clearTimeout(toast.timer);toast.timer=setTimeout(()=>toast.classList.remove('show'),3000);}
function updateSlots(){const s=document.getElementById('slots');s.innerHTML='';for(let i=0;i<8;i++){const d=document.createElement('div');d.className=`slot ${i<4?'used':'library'}`;d.textContent=slots[i]||(i<4?`已用 ${i+1}`:`卡组 ${i+5}`);s.appendChild(d);}document.getElementById('undoBtn').disabled=slots.length===0;}
function addCard(n){const w=Date.now();if(w-lastAddTime<600)return;if(slots[0]===n)return;slots.unshift(n);if(slots.length>8)slots.pop();lastAddTime=w;showToast(`添加: ${n}`);updateSlots();}
function renderAtlas(f=''){const l=document.getElementById('cardList');l.innerHTML='';allCards.filter(c=>c.includes(f)).forEach(c=>{const b=document.createElement('button');b.className='card-btn';b.textContent=c;b.onclick=()=>addCard(c);l.appendChild(b);});}
document.getElementById('searchInput').addEventListener('input',e=>renderAtlas(e.target.value));

// 配置保存
document.getElementById('getToken').onclick = function() {
  const appid = document.getElementById('appid').value.trim();
  const apiKey = document.getElementById('apiKey').value.trim();
  if (!appid || !apiKey) {
    showToast('请填写 AppID 和 API Key');
    return;
  }
  localStorage.setItem('baidu_appid', appid);
  localStorage.setItem('baidu_appkey', apiKey);
  document.getElementById('tokenStatus').textContent = '配置已保存';
  showToast('配置保存成功');
  document.getElementById('startBtn').disabled = false;
};

// 初始化加载
window.addEventListener('load', function() {
  const appid = localStorage.getItem('baidu_appid');
  if (appid) {
    document.getElementById('appid').value = appid;
    document.getElementById('apiKey').value = localStorage.getItem('baidu_appkey') || '';
    document.getElementById('startBtn').disabled = false;
  }
  sn = 'sn-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  renderAtlas();
  updateSlots();
});

// 处理识别结果（优化：对缓冲区实时检索）
function processResult(text) {
  transcriptBuffer += text + ' '; // 追加到缓冲区
  if (transcriptBuffer.length > MAX_BUFFER_LENGTH) {
    transcriptBuffer = transcriptBuffer.slice(-MAX_BUFFER_LENGTH); // 截断旧文本
  }
  speechText.textContent = transcriptBuffer.trim(); // 更新显示区

  const words = transcriptBuffer.replace(/[，。！？；：]/g, ' ').split(/\s+/).filter(w => w.trim());
  for (let word of words) {
    let card = word;
    if (aliasMap[word]) {
      card = aliasMap[word];
    }
    if (allCards.includes(card)) {
      addCard(card);
      showToast(`识别并添加: ${card}`);
      transcriptBuffer = ''; // 清空缓冲区，聚焦新输入
      speechText.textContent = '';
      break;
    }
  }
}

// 开始监听
document.getElementById('startBtn').onclick = async function() {
  const appid = localStorage.getItem('baidu_appid');
  const appkey = localStorage.getItem('baidu_appkey');
  if (!appid || !appkey) {
    showToast('请先保存配置');
    return;
  }
  reconnectAttempts = 0;
  transcriptBuffer = ''; // 重置缓冲区
  try {
    console.log('开始麦克风访问...');
    const stream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: SAMPLE_RATE, channelCount: 1 } });
    console.log('麦克风访问成功');
    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
    source = audioContext.createMediaStreamSource(stream);
    processor = audioContext.createScriptProcessor(4096, 1, 1);
    source.connect(processor);
    processor.connect(audioContext.destination);

    ws = new WebSocket(`wss://vop.baidu.com/realtime_asr?sn=${sn}`);
    ws.binaryType = 'arraybuffer';
    console.log('WebSocket连接建立中...');

    ws.onopen = () => {
      console.log('WebSocket打开，发送START');
      const startMsg = {
        type: 'START',
        data: {
          appid: parseInt(appid),
          appkey: appkey,
          dev_pid: 15372, // 普通话带标点
          cuid: cuid,
          format: 'pcm',
          sample: SAMPLE_RATE
        }
      };
      ws.send(JSON.stringify(startMsg));

      processor.onaudioprocess = (e) => {
        if (!isRecording) return;
        const inputBuffer = e.inputBuffer.getChannelData(0);
        const pcmData = new Int16Array(inputBuffer.length);
        for (let i = 0; i < inputBuffer.length; i++) {
          let s = Math.max(-1, Math.min(1, inputBuffer[i]));
          pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(pcmData.buffer); // 持续发送音频
        }
        // 移除沉默检测，依赖服务器自动分句
      };

      isRecording = true;
      document.getElementById('status').textContent = '持续实时监听中...';
      document.getElementById('startBtn').disabled = true;
      document.getElementById('stopBtn').disabled = false;
      document.getElementById('undoBtn').disabled = false;
      speechText.textContent = '';
      showToast('开始持续监听');
    };

    ws.onmessage = (event) => {
      if (typeof event.data === 'string') {
        const msg = JSON.parse(event.data);
        if (msg.type === 'MID_TEXT' || msg.type === 'FIN_TEXT') {
          if (msg.err_no === 0) {
            processResult(msg.result); // 实时追加并检索
          } else {
            console.error('识别错误:', msg.err_msg);
          }
        }
      }
    };

    ws.onclose = (event) => {
      console.log('WebSocket关闭:', event.code, event.reason);
      if (reconnectAttempts < MAX_RECONNECTS && isRecording) {
        reconnectAttempts++;
        console.log(`尝试重连... (${reconnectAttempts}/${MAX_RECONNECTS})`);
        setTimeout(() => {
          sn = 'sn-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9); // 新SN
          ws = new WebSocket(`wss://vop.baidu.com/realtime_asr?sn=${sn}`);
          ws.binaryType = 'arraybuffer';
          // 重新绑定事件（简化版，实际可提取函数）
          ws.onopen = () => {
            const startMsg = { type: 'START', data: { appid: parseInt(appid), appkey: appkey, dev_pid: 15372, cuid: cuid, format: 'pcm', sample: SAMPLE_RATE } };
            ws.send(JSON.stringify(startMsg));
            document.getElementById('status').textContent = `重连成功，继续监听...`;
          };
          ws.onmessage = ws.onmessage; // 复用
          ws.onclose = ws.onclose;
          ws.onerror = ws.onerror;
        }, 1000);
      } else {
        stopRecording();
        showToast('连接已关闭（重连失败）');
      }
    };

    ws.onerror = (err) => {
      console.error('WebSocket错误:', err);
      stopRecording();
      showToast('连接发生错误');
    };

  } catch (err) {
    console.error('麦克风访问失败:', err);
    showToast('无法访问麦克风，请检查权限');
  }
};

// 停止录音
function stopRecording() {
  isRecording = false;
  transcriptBuffer = '';
  if (processor) processor.disconnect();
  if (source) source.disconnect();
  if (audioContext) audioContext.close();
  if (ws) ws.close();
  reconnectAttempts = 0;
  document.getElementById('startBtn').disabled = false;
  document.getElementById('stopBtn').disabled = true;
  document.getElementById('status').textContent = '已停止监听';
  speechText.textContent = '听到的内容会实时显示在这里...';
}

// 停止按钮
document.getElementById('stopBtn').onclick = stopRecording;

// 撤销
document.getElementById('undoBtn').onclick = () => {
  if (slots.length > 0) {
    slots.shift();
    updateSlots();
    showToast('已撤销上一张牌');
  }
};

// 清空
document.getElementById('resetBtn').onclick = () => {
  slots = [];
  updateSlots();
  showToast('卡槽已清空');
};
</script>
</body>
</html>
